>💡 선형 자료 구조란 요소가 일렬로 나열되어 있는 자료 구조를 말한다.

[1. 연결 리스트](#1-연결-리스트)\
[2. 배열](#2-배열)\
[3. 벡터](#3-벡터)\
[4. 스택](#4-스택)\
[5. 큐](#5-큐)

## 1. 연결 리스트

> 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조.
> 

삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸린다.

- **싱글 연결 리스트**: next 포인터만 가진다.
- **이중 연결 리스트**: next 포인터와 prev 포인터를 가진다.
- **원형 이중 연결 리스트**: 이중 연결 리스트인데, 마지막 노드의 next 포인터가 헤드 노드를 가리킨다.

![image](https://user-images.githubusercontent.com/72758925/234014640-6788b5c0-4186-487e-91a1-c5982695d432.png)

---

## 2. 배열

> 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합. 또한, 중복을 허용하고 순서가 있다.
> 

탐색에 O(1)이 되어 랜덤 접근(random access)이 가능하다다. 삽입과 삭제에는 O(n)이 걸힌다. 따라서 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것은 배열로 하는 것이 좋다.

### 랜덤 접근과 순차적 접근

![image](https://user-images.githubusercontent.com/72758925/234014874-19726dd0-46c7-438b-bf08-03152be289e1.png)

저장된 순서대로 검색하는게 순차적 접근이고 임의의 인덱스에 해당하는 데이터에 접근하는게 랜덤 접근이다.

### 배열과 연결 리스트 비교

![image](https://user-images.githubusercontent.com/72758925/234015015-826849d9-4442-41a1-b6a0-df4cc52c2392.png)

- 배열은 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어 낼 수 있다. 연결 리스트는 상자 안의 요소를 알기 위해선 하나씩 상자 내부를 확인해봐야 한다.
- 데이터 추가 및 삭제는 연결 리스트가 더 빠르고 배열은 느리다. 배열은 모든 상자를 앞으로 옮겨야 추가가 가능하지만, 연결 리스트는 선을 바꿔서 연결해주기만 하면 되기 때문

---

## 3. 벡터

> 벡터(vector)는 동적으로 요소를 할당할 수 있는 동적 배열이다.
> 

중복을 허용하고 순서가 있고 랜덤 접근이 가능하다.

탐색과 맨 뒤의 요소를 삭제하거나 삽입하는 데 O(1)이 걸리며, 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는 데 O(n)의 시간이 걸린다.

![image](https://user-images.githubusercontent.com/72758925/234015406-1fb42884-b49d-4692-9950-448210bd9545.png)

![image](https://user-images.githubusercontent.com/72758925/234015472-2276964e-7a74-441e-b6ae-3e17b1fcd7a9.png)

그림과 같이 2의 제곱승 + 1 마다 용량을 두 배로 늘린다. 

삽입에 드는 비용이 위 수식과 같고 평균을 구하면 3이 되기 때문에 O(1)을 가지게 되는 것이다.

---

## 4. 스택

> 스택은 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조다.
> 

재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰인다. 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.

---

## 5. 큐

> 큐(queue)는 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료 구조다.

나중에 집어넣은 데이터가 먼저 나오는 스택과는 반대되는 개념을 가졌다. 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.