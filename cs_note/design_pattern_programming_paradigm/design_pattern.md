>💡 디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것
>

[1. 싱글톤 패턴](#1-싱글톤-패턴)\
[2. 팩토리 패턴](#2-팩토리-패턴)\
[3. 전략 패턴](#3-전략-패턴)\
[4. 옵저버 패턴](#4-옵저버-패턴)\
[5. 프록시 패턴과 프록시 서버](#5-프록시-패턴과-프록시-서버)\
[6. 이터레이터 패턴](#6-이터레이터-패턴)\
[7. 노출 모듈 패턴](#7-노출모듈-패턴)\
[8. MVC 패턴](#8-mvc-패턴)\
[9. MVP 패턴](#9-mvp-패턴)\
[10. MVVM 패턴](#10-mvvm-패턴)


# 1. 싱글톤 패턴

> 하나의 클래스가 오직 하나의 인스턴스만 가지는 패턴
> 
- 하나의 인스턴스를 여러 모듈들이 공유하기 때문에 인스턴스 생성 비용을 줄일 수 있다.
- 의존성이 높아진다는 단점이 있다.
- 데이터베이스 연결 모듈에 많이 사용된다. 데이터베이스 연결에 관한 인스턴스 생성 비용을 아낄 수 있다.

### 사용 예시

- mongoose : Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 모듈. mongoose의 데이터베이스를 연결할 때 쓰는 connect()라는 함수는 싱글톤 인스턴스를 반환한다.
- MySQL: Node.js에서 MySQL을 연결할 때도 싱글톤 패턴이 사용된다.

### 단점

- TDD의 걸림돌이 된다. TDD의 단위테스트들은 독립적으로 존재해야 순서에 상관없이 실행될 수 있는데, 싱글톤 패턴은 각 테스트마다 독립적인 인스턴스를 만들기가 어렵다.

### 의존성 주입

의존성 주입(Dependency Injection)을 통해 싱글톤 패턴으로 인한 모듈 간의 강한 결합을 느슨하게 만들 수 있다.  

A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미한다.

![image](https://user-images.githubusercontent.com/72758925/233764276-d8d3d431-82ff-4925-a82f-4ddf079873b4.png)


그림과 같이 메인 모듈이 하위 모듈들에 대해 직접 의존성을 주고 있다. 그러나 의존성 주입자를 중간에 넣어주면 메인 모듈이 간접적으로 의존성을 주게 된다.

이를 통해 메인 모듈에 하위 모듈에 대한 의존성이 떨어지게 된다.

<장점>

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기도 수월해진다.
- 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며 모듈 간
의 관계들이 조금 더 명확해진다.

<단점>

- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타
임 페널티가 생기기도 한다.

<의존성 주입의 원칙>

- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
- 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다.

---

# 2. 팩토리 패턴

> 코드에서 객체의 생성 부분을 따로 떼어내 추상화한 패턴, 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
> 
- 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가짐
- 상위 클래스에서는 인스턴스 생성 방식에 대해 알 필요가 없어 유연성을 갖게 됨
- 인스턴스 생성 로직이 분리되어 있기 때문에 리팩터링을 하더라도 한 곳만 고칠 수 있게 되니 유지 보수성 증가

---

# 3. 전략 패턴

> ‘정책 패턴’이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴.
> 

![image](https://user-images.githubusercontent.com/72758925/233764435-f9258fd2-5f22-4a30-9623-18808f8d9fa8.png)


어떤 물건을 살 때 네이버페이, 카카오페이 등 다양한 방법으로 결제하는 것과 같다.

### 사용 예시

- passport: Node.js에서 인증 모듈을 구현할 때 사용되는 미들웨어 라이브러리. 여러 가지 ‘전략’을 기반으로 인증할 수 있게 함. 서비스의 회원가입된 아이디나 비밀번호를 기반으로 인증할 수도 있고, 페이스북이나 네이버 등 다른 서비스를 기반으로 인증할 수도 있다.

---

# 4. 옵저버 패턴

> 주체가 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴.
> 


![image](https://user-images.githubusercontent.com/72758925/233764619-1060d11b-2d52-4c80-999d-3abdea4a26ef.png)

### 사용 예시

- 트위터: 어떤 사람을 팔로우 했다면 주체가 포스팅을 했을 때 팔로워들에게 모두 알림이 간다.
- 옵저버 패턴은 MVC패턴에도 사용된다.
    
    ![image](https://user-images.githubusercontent.com/72758925/233764648-5ee33e40-5d73-49b2-b4c3-8c359b269fac.png)
    
    주체라고 볼 수 있는 모델(model)에서 변경 사항이 생겨 update( ) 메서드로 옵저버인 View에 알려주고 이를 기반으로 컨트롤러(controller) 등이 작동하는 것
    
- Vue.js 3.0에서 어떤 값을 ref나 reactive로 정의하면 해당값이 변경되었을 때 자동으로 **DOM**(문서객체모델)에 있는 값이 변경

---

# 5. 프록시 패턴과 프록시 서버

> 프록시 패턴: 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
> 

![image](https://user-images.githubusercontent.com/72758925/233764771-9df392c3-41c3-4520-901a-e2714e1e6bdc.png)

이를 통해 객체의 속성 , 변환 등을 보완하며 보안 , 데이터 검증, 캐싱, 로깅에 등에 사용한다. 

> 프록시 서버: 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
> 

### 사용 예시

- nginx: 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버. 실제 웹 서버의 앞단에 nginx를 설치해 익명 사용자의 직접적인 서버로의 접근을 차단하고 간접적으로 한 단계를 더 거침으로써 보안성을 더욱 강화할 수 있음.
    
    ![image](https://user-images.githubusercontent.com/72758925/233764858-329dccbd-0ec0-4a2f-884c-fbed19b84a36.png)
    
- CloudFlare: 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 **CDN**(사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크) 서비스.
    
    ![image](https://user-images.githubusercontent.com/72758925/233764892-6cc01251-28dd-4496-a59e-f4d5bb62401f.png)
    
    그림과 같이 웹 서버 앞단에 프록시 서버를 둔다. DDOS공격이나 HTTPS구축 등을 이룰 수 있다.
    

### CORS와 프론트엔드 개발

CORS는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 **오리진**(프로토콜과 호스트 이름, 포트의 조합)을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.

프런트 엔드 개발 시 프런트 엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS에러를 마주치는데, 이를 해결하기 위해 프런트 엔드에서 프록시 서버를 만들기도 한다.

![image](https://user-images.githubusercontent.com/72758925/233764938-e7f0699b-d9e1-4fcb-b7ae-2e9db7b151c9.png)


---

# 6. 이터레이터 패턴

> 이터레이터 (iterator)를 사용하여 컬렉션 (collection)의 요소들에 접근하는 디자인 패턴
> 
- 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 객체들을 순회할 수 있게 해준다.

### 사용 예시

- 파이썬의 set()과 list() 모두 for문을 통해 순회할 수 있다.

---

# 7. 노출모듈 패턴

> 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
> 

---

# 8. MVC 패턴

> 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴
> 

![image](https://user-images.githubusercontent.com/72758925/233765064-176d2ef1-85a0-4602-915f-9c1e223080c1.png)

- 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 요소에만 집중해서 개발할 수 있게 한다.
- 재사용성과 확장성이 용이하다는 장점이 있다.
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.

### 모델

애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함.

뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신한다.

### 뷰

사용자 인터페이스 요소를 나타낸다.

모델을 기반으로 사용자가 볼 수 있는 화면을 뜻하며, 모델이 가지고 있는 정보를 따로 저장하지 않아야 한다. 또한, 변경이 일어나면 이를 컨트롤러에 전달해야 한다.

### 컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며, 이벤트 등 메인 로직을 담당.

모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌

### MTV 패턴?

장고(Django)가 사용하는 패턴. 템플릿(Template)이 MVC의 뷰에 대응되고, 뷰(View)가 MVC의 컨트롤러에 대응된다.

---

# 9. MVP 패턴

> MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴
> 

![image](https://user-images.githubusercontent.com/72758925/233765109-f4c0c810-8dfe-45c6-b42c-07c0591661c1.png)


- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 가진 패턴임

---

# 10. MVVM 패턴

> MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴.
> 

![image](https://user-images.githubusercontent.com/72758925/233765142-d39a0b1a-28ca-4f81-905b-48ec100f464b.png)


- MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가짐
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며, UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있다.

**커맨드**: 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법.

**데이터 바인딩**: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰 모델을 변경하면 뷰가 변경된다.

### 사용 예시

- Vue.js: 함수를 사용하지 않고 값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로
컴포넌트를 구축할 수 있다는 점이 특징. 재사용 가능한 컴포넌트 기반으로 UI를 구축할 수도 있음