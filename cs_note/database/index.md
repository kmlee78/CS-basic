[1. B-트리](#1-b-트리)\
[2. 인덱스를 만드는 방법](#2-인덱스를-만드는-방법)\
[3. 인덱스 최적화 기법](#3-인덱스-최적화-기법)

## 1. B-트리

> 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있다. 이는 **루트 노드**, **리프 노드**, 그리고 루트 노드와 리프 노드 사이에 있는 **브랜치 노드**로 나뉜다.
> 

예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 E가 있을 법한 리프 노드로 들어가서 E를 탐색하는 방식이다.

![image](https://user-images.githubusercontent.com/72758925/233774980-1a093a84-ad0f-4170-8eb2-3006f1b00732.png)

키 57에 해당하는 데이터를 검색해야 한다고 할 때, 트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려온다. ‘57보다 같거나 클 때 까지 ≤’를 기반으로 처음 루트 노드에서는 39, 83 이후 아래 노드로 내려와 46, 53, 57 등 정렬된 값을 기반으로 탐색하는 것을 볼 수 있다.

이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 57이 가리키는 데이터 포인터를 통해 결괏값을 반환한다.

### 인덱스가 효율적인 이유와 대수확장성

![image](https://user-images.githubusercontent.com/72758925/233775001-acfe29cf-5c24-4fc5-8ad9-7f82cd241021.png)

인덱스가 효율적인 이유는 대수확장성 때문인데, 대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다.

기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

표를 보면 깊이 10의 트리로 100만개의 레코드를 검색할 수 있다는 것을 알 수 있다.

---

## 2. 인덱스를 만드는 방법

> 인덱스를 만드는 방법은 데이터베이스마다 다르며 MySQL과 MongoDB 기준으로 알아보자
> 

### MySQL

세컨더리 인덱스는 보조 인덱스로, 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스다. 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋다.

- **클러스터형 인덱스:** 테이블당 하나를 설정할 수 있는 인덱스. primary key 옵션으로 기본키로 만들거나, 기본키로 만들지 않을 때는 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
- **세컨더리 인덱스:** create index … 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다.

### MongoDB

도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다. 그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

---

## 3. 인덱스 최적화 기법

### 인덱스는 비용이다

먼저 인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들게 된다. 또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 하기 때문에 또 비용이 든다. 그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다. 또한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.

### 항상 테스팅하라

인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 그렇기 때문에 항상 테스팅하는 것이 중요하다,
explain( ) 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.

### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인텍스 성능이 달라진다. 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

1. 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정한다.
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야한다. 예를 들어 age와 email이 있다고 할때, email이 카디널리티가 높다고 할 수 있다. 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야 하는 것이다.