>💡 데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다. 이들을 제어, 관리하는 통합 시스템을 DBMS라고 하며, 데이터들은 쿼리 언어를 통해 조회, 삽입, 수정, 삭제가 가능하다.

[1. 엔티티](#1-엔티티)\
[2. 릴레이션](#2-릴레이션)\
[3. 속성](#3-속성)\
[4. 도메인](#4-도메인)\
[5. 필드와 레코드](#5-필드와-레코드)\
[6. 관계](#6-관계)\
[7. 키](#7-키)

## 1. 엔티티

> 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미한다.
> 

예를 들어 회원이라는 엔터티가 있으면 회원 엔티티는 이름, 아이디, 주소, 전화번호라는 속성을 가지게 된다.

### 약한 엔티티와 강한 엔티티

엔티티는 이렇게 두가지로 나뉘는데, 예를 들어 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고 B는 강한 엔터티가 된다.

---

## 2. 릴레이션

> 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
> 

![image](https://user-images.githubusercontent.com/72758925/233772826-bc2bb851-f026-47e2-b183-12f292a7b690.png)

데이터베이스는 엔티티에 관한 데이터를 릴레이션 하나에 담아서 관리한다.

릴레이션은 관계형 데이터베이스에서는 ‘**테이블**’이라고 하며,

NoSQL 데이터베이스에서는 ‘**컬렉션**’이라고 한다,

### 테이블과 컬렉션

데이터베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다. 이 중 대표적인 관계형 데이터베이스인 MySQL과 대표적인 NoSQL 데이터베이스인 MongoDB를 예로 들면,

![image](https://user-images.githubusercontent.com/72758925/233772873-cabe45a9-a6c2-4e6f-a85d-6d09630c114f.png)

MySQL의 구조는 레코드 - 테이블 - 데이터베이스로 이루어져 있고,

MongoDB 데이터베이스의 구조는 도큐먼트 - 컬렉션 - 데이터베이스로 이루어져 있다.

그림처럼 레코드가 모여서 테이블이 되고 테이블이 모여서 데이터베이스가 되는 방식

---

## 3. 속성

> 속성(attribute)는 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보를 뜻한다.
> 

예를 들어 ‘차’라는 엔터티의 속성들 중에는 차 넘버, 바퀴 수, 차 색 깔, 차종 등이 있겠지

---

## 4. 도메인

> 도메인(domain)이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다.
> 

![image](https://user-images.githubusercontent.com/72758925/233772903-5ba7247d-9b09-4b8b-88c3-5d4c44b412d9.png)

예를 들어 다음 그림을 보면 회원 엔티티는 이름, 아이디, 주소, 전화번호, 성별이라는 속성을 가지고 있고, 

성별이라는 속성은 {남, 여} 중 하나의 값을 가질 수 있으니까 성별 속성은 {남, 여}라는 도메인을 가지는 것이다.

---

## 5. 필드와 레코드

![image](https://user-images.githubusercontent.com/72758925/233772927-6f14c725-d694-41c5-87d1-5b29ee9b4758.png)

member라는 테이블은 name, ID, address, phonenumber라는 **필드**를 가진다. 그리고 이 테이블에 쌓이는 행(row)단위의 데이터를 **레코드**라고 한다. 레코드를 튜플이라고도 한다.

### 필드 타입

필드는 타입을 갖는다.

- **숫자 타입**: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있다.
- **날짜 타입**: DATE, DATETIME, TIMESTAMP 등이 있다. DATE는 날짜만 표시하고 그 외에는 시간까지 포함한다.
- **문자 타입**: CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등이 있다.
    - CHAR 또는 VARCHAR 모두 그 안에 수를 입력해서 몇 자까지 입력할지 정한다. VARCHAR은 가변 길이 문자열이기 때문에 CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며, 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋다.
    - TEXT와 BLOB은 큰 데이터를 저장할 때 쓰이는 타입이다.
    - ENUM과 SET 모두 문자열을 열거한 타입이다.

---

## 6. 관계

> 테이블은 서로의 관계가 정의되어 있고, 이러한 관계를 관계화살표로 나타낸다.
> 

![image](https://user-images.githubusercontent.com/72758925/233772952-883b2488-eae1-45e9-823c-eb6ccc400391.png)

### 1:1 관계

![image](https://user-images.githubusercontent.com/72758925/233773133-3bbaf69f-8130-4873-9284-ff638fd0531b.png)

하나의 유저는 하나의 유저 이메일을 갖는다.

### 1:N 관계

![image](https://user-images.githubusercontent.com/72758925/233773145-66bbab60-0169-46cd-b32f-0286d79c9a2d.png)

한 개체가 다른 많은 개체를 포함하는 관계. 

한 유저당 여러 개의 상품을 장바구니에 넣을 수 있다.

### N:M 관계

![image](https://user-images.githubusercontent.com/72758925/233773185-2c448cf1-f11d-4cf6-b89a-04bba4c61363.png)

학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있다. 이 경우 N:M이 된다.

그림을 보면 중간에 학생_강의라는 테이블이 끼어 있다. N:M은 테이블 두 개를 직접적으로 연결해서 구축하지는 않고 1:N, 1:M 이라는 관계를 갖는 테이블 두 개로 나눠서 설정하는게 일반적이다.

---

## 7. 키

> 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.
> 

![image](https://user-images.githubusercontent.com/72758925/233773201-63e4f4ef-eb2c-450d-914f-e00ac2ea4dba.png)

슈퍼키는 유일성을 가지고 후보키는 거기다가 최소성을 가진다. 후보키 중 기본키로 선택되지 못한 키는 대체키가 된다.

**유일성**은 중복되는 값은 없으며, **최소성**은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말한다.

### 기본키

기본키(Primary Key)는 줄여 PK 또는 프라이머리키라고 많이 부르며, 유일성과 최소성을 만족하는 키다. 이는 테이블의 데이터 중 고유하게 존재하는 속성이며 기본키에 해당하는 데이터는 ID처럼 중복되어서는 안된다. {ID , name}이라는 복합키를 기본키로 설정할 수 있지만 그렇게 되면 최소성을 만족하지 않으니까 기본키가 아니다.

기본키는 자연키 또는 인조키 중에 골라서 설정한다.

**<자연키>**

중복된 값들을 제외하며 중복되지 않는 것을 ‘자연스레’ 뽑다가 나오는 키를 자연키 라고 한다. 자연키는 언젠가는 변하는 속성을 가진다.

**<인조키>**

인위적으로 생성한 키를 인조키라고 한다. 자연키와는 대조적으로 변하지 않아 보통 기본키는 인조키로 설정한다.

### 외래키

![image](https://user-images.githubusercontent.com/72758925/233773243-258e6f38-4b6f-4da8-bcba-a9d2295b8d94.png)

외래키(Foreign Key)는 FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용한다.

옆의 그림을 보면 client 라는 테이블의 기본키인 ID가 product라는 테이블의 user_id라는 외래키로 설정될 수 있는 것을 볼 수 있다. 외래키는 중복되어도 괜찮다.

### 후보키

후보키(candidate key)는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키다.

### 대체키

대체키(alternate key)는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 키다.

### 슈퍼키

슈퍼키(super key)는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키다.